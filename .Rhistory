library(tidyverse)
tb <- tibble(w = rnorm(howlong),
group = rep(c('A','B','C','D'),howlong/4),
gamma = rep(c(0,.5,.2,.4),howlong/4),
beta = rep(c(1,2,3,4),howlong/4),
z = rnorm(howlong)) %>%
mutate(x = z*gamma + w + rnorm(howlong)) %>%
mutate(y = x*beta + 2*w + rnorm(howlong))
howlong = 20
tb <- tibble(w = rnorm(howlong),
group = rep(c('A','B','C','D'),howlong/4),
gamma = rep(c(0,.5,.2,.4),howlong/4),
beta = rep(c(1,2,3,4),howlong/4),
z = rnorm(howlong)) %>%
mutate(x = z*gamma + w + rnorm(howlong)) %>%
mutate(y = x*beta + 2*w + rnorm(howlong))
Hmisc::label(tb$w) <- 'ho'
attr(tb$w,'label')
class=TUE
class=TRUE
values =TRUE
missing=FALSE
index=FALSE
factor.limit=5
char.values=FALSE
slow.ok=FALSE
data.title=NA
file=NA
out=NA
labels=NA
desc=NA
col.width=NA
summ=NA
data <- tb
#######CHECK INPUTS
if (is.null(colnames(data))) {
stop('Requires data with variable names or column names.')
}
if (!is.na(file) & !is.character(file)) {
stop('Incorrect file name.')
}
if (!is.logical(class)) {
stop('The class option must be TRUE or FALSE.')
}
if (!is.logical(values)) {
stop('The values option must be TRUE or FALSE.')
}
if (!is.logical(missing)) {
stop('The missing option must be TRUE or FALSE.')
}
if (!is.logical(index)) {
stop('The index option must be TRUE or FALSE.')
}
if (!is.numeric(factor.limit) | factor.limit%%1 != 0) {
stop('factor.limit must be an integer. Set to 0 for unlimited factors.')
}
if (!(is.logical(char.values) | is.character(char.values))) {
stop('char.values must be FALSE, TRUE, or a character vector.')
}
if (!is.na(data.title) & !is.character(data.title)) {
stop('data.title must be a character variable.')
}
if (!is.na(desc) & !is.character(desc)) {
stop('desc must be a character variable.')
}
if (min(is.na(col.width)) == 0 & (!is.vector(col.width) | !is.numeric(col.width) | sum(is.na(col.width)) > 0)) {
stop('col.width must be a numeric vector with no missing values.')
}
if (min(is.na(col.width)) == 0 & (max(col.width) > 100 | min(col.width) < 0)) {
stop('Elements of col.width must be between 0 and 100.')
}
if (min(is.na(summ)) == 0 & (!is.vector(summ) | !is.character(summ) | sum(is.na(summ)) > 0)) {
stop('summ must be a character vector with no missing values.')
}
#One-column matrices run into some problems later on
if (is.matrix(data) & dim(data)[2] == 1) {
data <- as.data.frame(data)
}
####### APPLICATION OF DATA.TITLE OPTION
#If data.title is missing, fill in with name of the data frame read in
if (is.na(data.title)) {
data.title <- deparse(substitute(data))
}
####### FORM VARIABLE TABLE TO BUILD ON
#If index = TRUE, start with that. Otherwise, start wtih Name
if (index==TRUE) {
vt <- data.frame(Index=1:ncol(data),
Name=colnames(data))
} else {
#Start table with variable names or column names (earlier error check ensures one exists)
vt <- data.frame(Name = colnames(data))
}
#If user asks for variable classes, add them to the variable table
if (class == TRUE) {
#If multiple classes listed, take the first
vt$Class <- sapply(data,function(x) class(x)[1])
}
#We need only one class
#If there are multiples and one is factor, treat as factor
if (sum(sapply(data,function(x) (length(class(x)) >1) & (is.factor(x)))) > 0) {
data[,sapply(data,function(x) (length(class(x)) >1) & (is.factor(x)))] <-
as.data.frame(sapply(data[,sapply(data,function(x) (length(class(x)) >1) & (is.factor(x)))],function(x) factor(x,ordered=FALSE)))
}
#Similarly, only take one class if it's numeric.
if (sum(sapply(data,function(x) (length(class(x)) >1) & (is.numeric(x)))) > 0) {
data[,sapply(data,function(x) (length(class(x)) >1) & (is.numeric(x)))] <-
as.numeric(data[,sapply(data,function(x) (length(class(x)) >1) & (is.numeric(x)))])
}
sum(sapply(data,function(x) (length(class(x)) >1) & (is.numeric(x))))
data[,sapply(data,function(x) (length(class(x)) >1) & (is.numeric(x)))]
class(data[,sapply(data,function(x) (length(class(x)) >1) & (is.numeric(x)))])
class(tb$w)
class(data$w)
as.numeric(data$w)
#Similarly, only take one class if it's numeric.
if (sum(sapply(data,function(x) (length(class(x)) >1) & (is.numeric(x)))) > 0) {
data[,sapply(data,function(x) (length(class(x)) >1) & (is.numeric(x)))] <-
as.data.frame(sapply(data[,sapply(data,function(x) (length(class(x)) >1) & (is.numeric(x)))],function(x) as.numeric(x)))
#as.numeric(data[,sapply(data,function(x) (length(class(x)) >1) & (is.numeric(x)))])
}
class(data$w)
attr(data$w,'label')
sapply(data, function(x) attr(x,'label'))
sapply(tb, function(x) attr(x,'label'))
data <- tb
#If labels are directly included, override the embedded labels
#Use ifelse construction so that labels[1] is not evaluated for two-column
#label styles (which throws an error)
if (min(is.na(labels))==0 & ifelse(length(labels) == 1,labels[1] != "omit",TRUE)) {
#Override embedded labels
vt$Label <- NULL
#Figure out the format of the data and fill in labs appropriately
#First, check if it's just a vector of labels
if (is.vector(labels)) {
#Make sure it's the right length
if (length(labels) == dim(vt)[1]) {
vt$Label <- labels
} else {
stop('label vector must have as many elements as there are variables in the data. Use NA elements to fill in, or see help(vtable) for other label formats that do not require every variable to have a label.')
}
#Check if it's in the two-column format
} else if(dim(labels)[1] > 1 & dim(labels)[2] == 2) {
#Put labels in mergeable format
labels <- as.data.frame(labels)
names(labels) <- c('Name','Label')
#Hold original order
vt$order <- 1:nrow(vt)
#Bring in variable labels by name, allow NA labels with all.x=TRUE
vt <- merge(vt,labels,sort=FALSE,all.x=TRUE)
vt <- vt[order(vt$order),]
vt$order <- NULL
#Keep row names in order
rownames(vt) <- 1:nrow(vt)
#Check if it's in the one-row variable-name format
} else if (dim(labels)[1]==1 & !is.null(colnames(labels))) {
#Put into two-column format
labs <- data.frame(Name=colnames(labels),Label=as.character(t(labels[1,])))
#Hold original order
vt$order <- 1:nrow(vt)
#Bring in variable labels by name, allow NA labels with all.x=TRUE
vt <- merge(vt,labs,sort=FALSE,all.x=TRUE)
vt <- vt[order(vt$order),]
vt$order <- NULL
rownames(vt) <- 1:nrow(vt)
} else{
stop('Unrecognized label format. See help(vtable).')
}
} else if (min(is.na(labels))==0 & ifelse(length(labels) == 1,labels[1] == "omit",FALSE)) {
vt$Label <- NULL
}
View(vt)
####### APPLICATION OF LABELS OPTION
#Pull from label attribute if present
#label attribute works for labels from Hmisc, sjlabelled, haven
labs <- sapply(data, function(x) attr(x,'label'))
#If there were any, add them
if (!is.null(unlist(labs))) {
vt$Label <- labs
}
#If labels are directly included, override the embedded labels
#Use ifelse construction so that labels[1] is not evaluated for two-column
#label styles (which throws an error)
if (min(is.na(labels))==0 & ifelse(length(labels) == 1,labels[1] != "omit",TRUE)) {
#Override embedded labels
vt$Label <- NULL
#Figure out the format of the data and fill in labs appropriately
#First, check if it's just a vector of labels
if (is.vector(labels)) {
#Make sure it's the right length
if (length(labels) == dim(vt)[1]) {
vt$Label <- labels
} else {
stop('label vector must have as many elements as there are variables in the data. Use NA elements to fill in, or see help(vtable) for other label formats that do not require every variable to have a label.')
}
#Check if it's in the two-column format
} else if(dim(labels)[1] > 1 & dim(labels)[2] == 2) {
#Put labels in mergeable format
labels <- as.data.frame(labels)
names(labels) <- c('Name','Label')
#Hold original order
vt$order <- 1:nrow(vt)
#Bring in variable labels by name, allow NA labels with all.x=TRUE
vt <- merge(vt,labels,sort=FALSE,all.x=TRUE)
vt <- vt[order(vt$order),]
vt$order <- NULL
#Keep row names in order
rownames(vt) <- 1:nrow(vt)
#Check if it's in the one-row variable-name format
} else if (dim(labels)[1]==1 & !is.null(colnames(labels))) {
#Put into two-column format
labs <- data.frame(Name=colnames(labels),Label=as.character(t(labels[1,])))
#Hold original order
vt$order <- 1:nrow(vt)
#Bring in variable labels by name, allow NA labels with all.x=TRUE
vt <- merge(vt,labs,sort=FALSE,all.x=TRUE)
vt <- vt[order(vt$order),]
vt$order <- NULL
rownames(vt) <- 1:nrow(vt)
} else{
stop('Unrecognized label format. See help(vtable).')
}
} else if (min(is.na(labels))==0 & ifelse(length(labels) == 1,labels[1] == "omit",FALSE)) {
vt$Label <- NULL
}
View(vt)
library(vtable)
vtable(tb)

#Get a list of the variables that each column covers
col.windows <- c(0,col.breaks)
col.vars <- lapply(1:length(col.breaks), function(x) (col.windows[x]+1):col.breaks[x])
#Summary function defaults, and fill in summ.names as well
#Are we filling summ.names at the same time?
fill.sn <- identical(summ.names,NA)
if (identical(summ,NA)) {
summ <- list()
if (fill.sn) {
summ.names <- list()
}
for (i in 1:length(col.vars)) {
if (all(var.classes[col.vars[[i]]] == 'factor')) {
summ[[i]] <- c('sum(x)','mean(x)')
if (fill.sn & factor.percent) {
summ.names[[i]] <- c('N','Percent')
} else {
summ.names[[i]] <- c('N','Mean')
}
} else if ((is.na(group) | group.long == TRUE) & length(col.breaks) == 1) {
summ[[i]] <- c('notNA(x)','mean(x)','sd(x)','min(x)','pctile(x)[25]','pctile(x)[75]','max(x)')
if (fill.sn) {
summ.names[[i]] <- c('N','Mean','Std. Dev.','Min','Pctl. 25','Pctl. 75','Max')
}
} else if ((is.na(group) | group.long == TRUE) & length(col.breaks) > 1) {
summ[[i]] <- c('notNA(x)','mean(x)','sd(x)')
if (fill.sn) {
summ.names[[i]] <- c('N','Mean','Std. Dev.')
}
} else {
summ[[i]] <- c('notNA(x)','mean(x)','sd(x)')
if (fill.sn) {
summ.names[[i]] <- c('N','Mean','SD')
}
}
}
} else if (!is.list(summ)) {
#If summ was entered as a vector, turn it into a list
#And copy it if there are multiple columns
summ <- lapply(1:length(col.vars), function(x) summ)
}
#Figure if digits started as a list or vector. If it did,
#ignore the auto-zero-digits for integers
digits.was.list <- is.list(digits)
if (is.vector(digits)) {
if (length(digits) > 1) {
digits.was.list <- TRUE
}
}
#Now fill in values for digits
if (identical(digits,NA)) {
digits <- list()
for (i in 1:length(col.breaks)) {
digits[[i]] <- rep(3,length(summ[[i]]))
digits[[i]][1] <- 0
}
} else if (is.numeric(digits)) {
if (length(digits) == 1) {
digopt <- digits
digits <- list()
for (i in 1:length(col.breaks)) {
digits[[i]] <- rep(digopt,length(summ[[i]]))
}
} else {
digits <- lapply(1:length(col.breaks), function(x) digits)
}
}
#If we have fixed.digits and digits weren't
#explicitly set by list,
#set digits to 0 for integers
if (fixed.digits & !digits.was.list) {
for (i in 1:length(summ)) {
for (j in 1:length(summ[[i]])) {
# Attempt to calc each variable for this function
calcs <- sapply(vars, function(x) parsefcn_summ(data[[x]],summ[[i]][j]))
calcs <- calcs[!is.na(calcs)]
if (is.round(calcs) | summ[[i]][j] == 'notNA(x)') {
digits[[i]][j] <- 0
}
}
}
}
#And fill in summ.names the rest of the way
#If a vector was specified for summ.names, turn it into a list
if (!fill.sn & !is.list(summ.names)) {
summ.names <- lapply(1:length(col.vars), function(x) summ.names)
}
#If summ.names is still missing, create it from summ
if (identical(summ.names,NA)) {
summ.names <- list()
for (i in 1:length(col.vars)) {
functionsused <- summ[[i]]
functionsused <- sub('\\(x\\)','',functionsused)
firstletters <- toupper(substring(functionsused,1,1))
summ.names[[i]] <- paste0(firstletters,substring(functionsused,2))
}
}
out %in% c('latex','latexpage') |
(isTRUE(getOption('knitr.in.progress')) & out == '' & isTRUE(knitr::is_latex_output()))
out %in% c('return','kable') |
(isTRUE(getOption('knitr.in.progress')) & out == '' & isFALSE(knitr::is_latex_output()) & isFALSE(knitr::is_html_output()))
#group.test defaults
#send the options to .opts, and make group.test be logical
if (identical(group.test,TRUE)) {
if (out %in% c('latex','latexpage') |
(isTRUE(getOption('knitr.in.progress')) & out == '' & isTRUE(knitr::is_latex_output()))) {
group.test.opts <- list(format = '{name}$={stat}^{{stars}}$')
} else if (out %in% c('return','kable') |
(isTRUE(getOption('knitr.in.progress')) & out == '' & isFALSE(knitr::is_latex_output()) & isFALSE(knitr::is_html_output()))) {
group.test.opts <- list(format = '{name}={stat}{stars}')
} else {
group.test.opts <- list(format = '{name}={stat}<sup>{stars}</sup>')
}
} else if (is.list(group.test)) {
group.test.opts <- group.test
group.test <- TRUE
}
help(is_latex_output, package = 'knitr')
help(TRUE)
help(isTRUE)
st(iris)
vtable::st(iris)
vtable::st(iris, group = 'Species', group.test = TRUE)
pkgdown::build_site
pkgdown::build_site()
vtable::vt(iris, out = 'kable')
data(efc, package='sjlabelled')
vtable::lt(efc, out = 'kable')
vtable::labeltable(efc, out = 'kable')
vtable::labeltable(efc$e16sex, out = 'kable')
pkgdown::build_site()
roxygen2::roxygenize()
pkgdown::build_home()
pkgdown::build_home()
pkgdown::build_home()
pkgdown::build_home()
library(vtable)
roxygen2::roxygenise()
setwd("C:/Users/nickc/Dropbox (CSU Fullerton)/General Work/vtable/vtable")
roxygen2::roxygenise()
pkgdown::build_site()
library(vtable)
roxygen2::roxygenise()
setwd("C:/Users/nickc/Dropbox (CSU Fullerton)/General Work/vtable/vtable")
roxygen2::roxygenise()
library(vtable)
pkgdown::build_site()
setwd("C:/Users/nickc/Dropbox (CSU Fullerton)/General Work/vtable/vtable")
pkgdown::build_site()
library(roxygen2)
sessionInfo(roxygen2)
sessionInfo()
roxygen2::roxygenise()
library(vtable)
roxygen2::roxygenise()
library(vtable)
devtools::check()
roxygen2::roxygenize()
roxygen2::roxygenize()
warnings()
roxygen2::roxygenize()
help(vt)
devtools::check()
devtools::check(args='--as-cran')
df <- haven::read_dta("C:\Users\nickc\OneDrive - Seattle University\Teaching\Econometrics Winter 20\Homework and Answers\week_8_binary_depvar_replications.dta")
df <- haven::read_dta("C:/Users/nickc/OneDrive - Seattle University/Teaching/Econometrics Winter 20/Homework and Answers/week_8_binary_depvar_replications.dta")
vtable::vt(df)
vtable::vt(df, char.values = TRUE)
table(df$RCT)
data = df
out=NA;file=NA;labels=NA;class=TRUE;values=TRUE;missing=FALSE;
index=FALSE;factor.limit=5;char.values=FALSE;
data.title=NA;desc=NA;note = NA;anchor=NA;col.width=NA;col.align=NA;
align=NA;summ=NA;lush=FALSE;opts=list()
char.values = TRUE
#Bring in opts
list2env(opts,envir=environment())
#######CHECK INPUTS
if (is.null(colnames(data))) {
stop('Requires data with variable names or column names.')
}
if (!is.na(file) & !is.character(file)) {
stop('Incorrect file name.')
}
if (!is.logical(class)) {
stop('The class option must be TRUE or FALSE.')
}
if (!is.logical(values)) {
stop('The values option must be TRUE or FALSE.')
}
if (!is.logical(missing)) {
stop('The missing option must be TRUE or FALSE.')
}
if (!is.logical(index)) {
stop('The index option must be TRUE or FALSE.')
}
if (!is.numeric(factor.limit) | factor.limit%%1 != 0) {
stop('factor.limit must be an integer. Set to 0 for unlimited factors.')
}
if (!(is.logical(char.values) | is.character(char.values))) {
stop('char.values must be FALSE, TRUE, or a character vector.')
}
if (!is.na(data.title) & !is.character(data.title)) {
stop('data.title must be a character variable.')
}
if (!is.na(desc) & !is.character(desc)) {
stop('desc must be a character variable.')
}
if (!identical(anchor,NA) & !is.character(anchor)) {
stop('anchor must be a character variable.')
}
if (min(is.na(col.width)) == 0 & (!is.vector(col.width) | !is.numeric(col.width) | sum(is.na(col.width)) > 0)) {
stop('col.width must be a numeric vector with no missing values.')
}
if (min(is.na(col.width)) == 0 & (max(col.width) > 100 | min(col.width) < 0)) {
stop('Elements of col.width must be between 0 and 100.')
}
if (min(is.na(summ)) == 0 & (!is.vector(summ) | !is.character(summ) | sum(is.na(summ)) > 0)) {
stop('summ must be a character vector with no missing values.')
}
if (!is.logical(lush)) {
stop('lush must be logical.')
}
if (!identical(out,NA) & !(out %in% c('viewer', 'browser','return','htmlreturn','kable','latex','latexpage'))) {
stop('out must be viewer, browser, return, htmlreturn, kable, latex, or latexpage')
}
#One-column matrices run into some problems later on
if (is.matrix(data) & dim(data)[2] == 1) {
data <- as.data.frame(data)
}
####### APPLICATION OF LUSH DEFAULTS
if (lush) {
char.values <- TRUE
missing <- TRUE
if (is.na(summ)) {
summ <- c('mean(x)', 'sd(x)', 'nuniq(x)')
}
}
####### APPLICATION OF DATA.TITLE OPTION
#If data.title is missing, fill in with name of the data frame read in
if (is.na(data.title)) {
data.title <- deparse(substitute(data))
}
####### FORM VARIABLE TABLE TO BUILD ON
#If index = TRUE, start with that. Otherwise, start with Name
if (index==TRUE) {
vt <- data.frame(Index=1:ncol(data),
Name=colnames(data))
} else {
#Start table with variable names or column names (earlier error check ensures one exists)
vt <- data.frame(Name = colnames(data))
}
#If user asks for variable classes, add them to the variable table
if (class == TRUE) {
#If multiple classes listed, take the first
vt$Class <- sapply(data,function(x) class(x)[1])
}
####### APPLICATION OF LABELS OPTION
#Pull from label attribute if present
#label attribute works for labels from Hmisc, sjlabelled, haven
labs <- sapply(data, function(x) attr(x,'label'))
#If there were any, add them
if (!is.null(unlist(labs))) {
vt$Label <- labs
}
#If labels are directly included, override the embedded labels
#Use ifelse construction so that labels[1] is not evaluated for two-column
#label styles (which throws an error)
if (min(is.na(labels))==0 & ifelse(length(labels) == 1,labels[1] != "omit",TRUE)) {
#Override embedded labels
vt$Label <- NULL
#Figure out the format of the data and fill in labs appropriately
#First, check if it's just a vector of labels
if (is.vector(labels)) {
#Make sure it's the right length
if (length(labels) == dim(vt)[1]) {
vt$Label <- labels
} else {
stop('label vector must have as many elements as there are variables in the data. Use NA elements to fill in, or see help(vtable) for other label formats that do not require every variable to have a label.')
}
#Check if it's in the two-column format
} else if(dim(labels)[1] > 1 & dim(labels)[2] == 2) {
#Put labels in mergeable format
labels <- as.data.frame(labels)
names(labels) <- c('Name','Label')
#Hold original order
vt$order <- 1:nrow(vt)
#Bring in variable labels by name, allow NA labels with all.x=TRUE
vt <- merge(vt,labels,sort=FALSE,all.x=TRUE)
vt <- vt[order(vt$order),]
vt$order <- NULL
#Keep row names in order
rownames(vt) <- 1:nrow(vt)
#Check if it's in the one-row variable-name format
} else if (dim(labels)[1]==1 & !is.null(colnames(labels))) {
#Put into two-column format
labs <- data.frame(Name=colnames(labels),Label=as.character(t(labels[1,])))
#Hold original order
vt$order <- 1:nrow(vt)
#Bring in variable labels by name, allow NA labels with all.x=TRUE
vt <- merge(vt,labs,sort=FALSE,all.x=TRUE)
vt <- vt[order(vt$order),]
vt$order <- NULL
rownames(vt) <- 1:nrow(vt)
} else{
stop('Unrecognized label format. See help(vtable).')
}
} else if (min(is.na(labels))==0 & ifelse(length(labels) == 1,labels[1] == "omit",FALSE)) {
vt$Label <- NULL
}
vt
####### We need only one class
#If there are multiples and one is factor, treat as factor
if (sum(sapply(data,function(x) (length(class(x)) >1) & (is.factor(x)))) > 0) {
data[,sapply(data,function(x) (length(class(x)) >1) & (is.factor(x)))] <-
as.data.frame(sapply(data[,sapply(data,function(x) (length(class(x)) >1) & (is.factor(x)))],function(x) factor(x,ordered=FALSE)))
}
#Similarly, only take one class if it's numeric.
if (sum(sapply(data,function(x) (length(class(x)) >1) & (is.numeric(x)))) > 0) {
data[,sapply(data,function(x) (length(class(x)) >1) & (is.numeric(x)))] <-
as.data.frame(sapply(data[,sapply(data,function(x) (length(class(x)) >1) & (is.numeric(x)))],function(x) as.numeric(x)))
}
values
class(char.values)
char.values
#See which are characters
charvariables <- as.logical(unlist(sapply(data,function(x) max(class(x) == "character"))))
charvariables
#and convert
data[,charvariables] <- as.data.frame(sapply(data[,charvariables],function(x) as.factor(x)))
sapply(data, class)
class(as.factor(data$Title))
as.data.frame(sapply(data[,charvariables],function(x) as.factor(x)))
sapply(as.data.frame(sapply(data[,charvariables],function(x) as.factor(x))),class)
charvariables
data[,charvariables]
vtable::vt(as.data.frame(df))
vtable::vt(as.data.frame(df, char.values = TRUE))
sapply(data[,charvariables],function(x) as.factor(x))
#and convert
data[,charvariables] <- as.data.frame(sapply(data[,charvariables],function(x) as.factor(x)), stringsAsFactors = TRUE)
data
library(vtable)
vt(df)
sapply(df, class)
df$_merge
df$`_merge`
class(df$`_merge`)
as.numeric(df$`_merge`)
attr(df$`_merge`,'labels')
as.integer(df$`_merge`)
as.factor(df$`_merge`)
as_factor(df$`_merge`)
class(haven::zap_labels(df$`_merge`))
library(vtable)
vt(df)
vt(df, char.values=TRUE)
vt(df, char.values='RCT')
col.width <- c(44, rep(8,7))
align <- paste0('p{',col.width/100,'\\textwidth}')
align
paste0('@{\\hskip .2in}',align[2:length(align)][names(st) == 'Variable'])
st <- data.frame(Variable = a, a = 2, b = 3, c = 4, d = 5, e = 6, f = 7, g = 8)
st <- data.frame(Variable = 'a', a = 2, b = 3, c = 4, d = 5, e = 6, f = 7, g = 8)
paste0('@{\\hskip .2in}',align[2:length(align)][names(st) == 'Variable'])
align[names(st) == 'Variable'] <- paste0('@{\\hskip .2in}',align[2:length(align)][names(st) == 'Variable'])
align <- paste0(align,collapse='')
align
align <- paste0('p{',col.width/100,'\\textwidth}')
align[2:length(align)][names(st) == 'Variable']
align[names(st) == 'Variable'][2:length(names(st) == 'Variable')] <- paste0('@{\\hskip .2in}',align[names(st) == 'Variable'][2:length(names(st) == 'Variable')])
align[names(st) == 'Variable'][2:length(names(st) == 'Variable')]
align <- paste0('p{',col.width/100,'\\textwidth}')
align[names(st) == 'Variable'][2:length(names(st) == 'Variable')]
align[names(st) == 'Variable'][2:sum(names(st) == 'Variable')]
st
names(st)[5] <-'Variable'
1:10[-3]
(1:10)[-3]
align <- paste0('p{',col.width/100,'\\textwidth}')
align
if (sum(names(st) == 'Variable') > 1) {
align[names(st) == 'Variable'][-1] <- paste0('@{\\hskip .2in}',align[names(st) == 'Variable'][-1])
}
lign
align
align <- paste0(align,collapse='')
align
roxygen2::roxygenise()
rm(st)
roxygen2::roxygenise()
library(vtable)
library(vtable)
roxygen2::roxygenise()
roxygen2::roxygenise()
library(vtable)
lubridate::is.Date
lubridate::is.Date()
is(as.Date('2020-03-04'),'Date')
is(as.POSIXct('2020-03-04'),'Date')
class(as.Date('2020-03-04'))
class(as.POSIXct('2020-03-04'))
class(lubridate::ymd('2020-03-4'))
class(lubridate::ymd('2020-0304'))
class(lubridate::ymd('2020-03-04'))
class(lubridate::ymd_hms('2020-03-04 00:00:00'))
min(lubridate::ymd_hms('2020-03-04 00:00:00'))
class(as.POSIXlt('2020-03-04'))
as.POSIXct('2020-03-04 00:00:00')
as.POSIXlt('2020-03-04 00:00:00')
dt <- data.frame(a = as.Date(c('2020-03-04','2020-05-06')), b = as.POSIXct('2020-03-04 00:00:00', '2020-05-01 01:02:03'), c = as.POSIXlt('2020-03-04 00:00:00', '2020-05-01 01:02:03'), d = 1:2)
dt <- data.frame(a = as.Date(c('2020-03-04','2020-05-06')), b = as.POSIXct(c('2020-03-04 00:00:00', '2020-05-01 01:02:03')), c = as.POSIXlt(c('2020-03-04 00:00:00', '2020-05-01 01:02:03')), d = 1:2)
dt
vt(dt)
class(dt$a) %in% c("Date",'POSIXct')
data = dt
sapply(data,function(x) class(x) %in% c('Date','POSIXct','POSIXt','POSIXlt') & min(is.na(x)) == 0)
vt(dt)
library(vtable)
vt(dt)
sapply(data,function(x) max(class(x) %in% c('Date','POSIXct','POSIXt','POSIXlt')) & min(is.na(x)) == 0)
sum(sapply(data,function(x) max(class(x) %in% c('Date','POSIXct','POSIXt','POSIXlt')) & min(is.na(x)) == 0)) > 0
lapply(subset(data,select=sapply(data,function(x) max(class(x) %in% c('Date','POSIXct','POSIXt','POSIXlt')) & min(is.na(x)) == 0)),function(x) min(x,na.rm=TRUE))
#Get minimums, be sure to skip any variables that are always NA
min <- lapply(subset(data,select=sapply(data,function(x) max(class(x) %in% c('Date','POSIXct','POSIXt','POSIXlt')) & min(is.na(x)) == 0)),function(x) min(x,na.rm=TRUE))
#Get maximums
max <- lapply(subset(data,select=sapply(data,function(x) max(class(x) %in% c('Date','POSIXct','POSIXt','POSIXlt')) & min(is.na(x)) == 0)),function(x) max(x,na.rm=TRUE))
min
class(min)
#Range description
range <- paste('Time:',min,'to',max)
range
#Range description
range <- paste('Time:',as.character(min),'to',as.character(max))
range
min
max
as.character(max)
as.character(unlist(max))
format(unlist(max))
toString(max)
strftime(max[1])
class(max)
class(max[1])
class(max[[1]])
class(max[[2]])
sapply(max, as.character)
#Get minimums, be sure to skip any variables that are always NA
min <- lapply(subset(data,select=sapply(data,function(x) max(class(x) %in% c('Date','POSIXct','POSIXt','POSIXlt')) & min(is.na(x)) == 0)),function(x) min(x,na.rm=TRUE))
min <- sapply(min, as.character)
#Get maximums
max <- lapply(subset(data,select=sapply(data,function(x) max(class(x) %in% c('Date','POSIXct','POSIXt','POSIXlt')) & min(is.na(x)) == 0)),function(x) max(x,na.rm=TRUE))
max <- sapply(max, as.character)
#Range description
range <- paste('Time:',min,'to',max)
range
data
data$b[1] <- as.POSIXct('2020-05-03 01:12:14')
#Get minimums, be sure to skip any variables that are always NA
min <- lapply(subset(data,select=sapply(data,function(x) max(class(x) %in% c('Date','POSIXct','POSIXt','POSIXlt')) & min(is.na(x)) == 0)),function(x) min(x,na.rm=TRUE))
min <- sapply(min, as.character)
#Get maximums
max <- lapply(subset(data,select=sapply(data,function(x) max(class(x) %in% c('Date','POSIXct','POSIXt','POSIXlt')) & min(is.na(x)) == 0)),function(x) max(x,na.rm=TRUE))
max <- sapply(max, as.character)
#Range description
range <- paste('Time:',min,'to',max)
range
vt(data)
dt
vt(dt)
class(range)
vt(dt)
roxygen2::roxygenize
roxygen2::roxygenize()
library(vtable)
library(vtable)
vtable(mtcars)
library(vtable)
vtable(mtcars)
getwd()
vtable(mtcars, out = 'csv')
vtable(mtcars, out = 'csv', file = 'foo')
help(write.csv)
file.path()
library(vtable)
st(mtcars)
st(mtcars, out = 'csv')
st(mtcars, out = 'csv', file = 'foo.csv')
st(mtcars, out = 'csv', file = 'foo.csv', group = 'am', group.test = TRUE)
st(mtcars, out = 'return',group = 'am', group.test = TRUE)
library(vtable)
vt(mtcars, out = 'csv', lush=TRUE)
vt(mtcars, out = 'return', lush=TRUE)
help(sumtable)
help(sumtable, package = 'vtable')
roxygen2::roxygenize()
library(vtable)
help(sumtable)
help(mean)
help(sumtable)
help(vtable)
help(labeltable)
st(mtcars, out = 'latex')
st(mtcars, group = 'am', group.test = TRUE,out = 'latex')
st(mtcars, group = 'am', group.test = TRUE,out = 'latex', note.align = 'p{.8\\textwidth}')
library(vtable)
roxygen2::roxygenise()
pkgdown::build_site()
library(rmarkdown)
install.packages('pkgdown',dependencies = TRUE)
pkgdown::build_site()
library(vtable)
